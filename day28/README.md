

# day28

## 网络编程
## 内容介绍

### 打基础

- 了解一些网络的基础知识
- 简单的了解一些底层网络通信

### 3-4天
- 网络的概念
- 基于原生的网络模块实现通信
- 完成一些简单的程序
- 了解一些协议的特点，扬长避短



## 网络基础概念

类似于学号和身份证号，学号会随着学校改变而改变，但是身份证号我们都是唯一的。网络中也有一个不变的地址和变化的地址：

- 不变的：mac地址。网卡上有一个地址(16进制)，是出厂的时候编的。每个网卡的前面几个都代表一个厂家。**mac地址永远不会重复，唯一的标识机器**
- 变化的：ip地址。



- 为什么有了mac地址还需要ip地址呢？

>  类似于送快递的时候找地址的逻辑，首先找一个大地方，然后不断缩小范围，



注意如果拔掉旁边电脑的网线连接上本机，虽然ip地址同，但是mac地址不同，消息还是不会送到

### 局域网中的通信

连在同一个交换机上的机器形成了一个局域网，局域网中所有消息传递全部交给交换机做，遗憾的是交换机只认识mac地址。

如果局域网中一个机器想要找到另一台机器，此时只知道目标ip地址，首先要发消息(会带上自己的mac地址以及ip)给交换机(因为交换机不认识ip地址，所以交换机此时会建立一个映射表，将发送机器的mac地址与对应的ip地址一一存起来)，之后交换机会将消息发送给所有的机器(**广播**)，之后只有目标机器才会回复(会带上自己的mac地址，此时交换机将会加入一个新的mac地址以及Ip地址映射记录)。之后如果向机器发送消息，

- 首先交换机会查询是否在表中，如果不在就大喊一声，收到回复，加入对应的mac地址到表中。

- 如果在表中则直接发送(**单播**)



交换机的功能：单播，广播，组播(只给一部分机器发消息，另外一部分不发)



交换机只认识mac地址，可以帮助我们形成局域网(局域网中多台机器可以发消息)， 

![image-20200613110959607](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200613110959607.png)

**通过知道一台机器的Ip地址，获取对应的mac地址的过程叫做ARP(中文名：地址解析协议)协议，用到了交换机的广播和单播功能**



### 局域网间的通信

不能将所有机器都放入到一个局域网中：响应时间太长，网络拥挤，安全问题（可以在自己的局域网外加一个防护措施），



**局域网之间的通信需要借助路由器，局域网内的通信借助交换机**



局域网之间通信：第一个局域网中的机器首先发消息给交换机，交换机将信息发送给路由器中的代理自己的那个人，然后代理自己的那个人(**网关**)再将消息在路由器内部发送给目标机器交换机在该路由器代理的那个人(**网关**)，然后再转发给目标机器所在的交换机，最后送达目标机器。



注意：我们对外面网络的ip就是网关的ip地址，所以爬虫的时候如果被封(封的是网关ip)，那么整个一个局域网对外的Ip都是这个，所以整个局域网内的机器都不可以继续爬取。



此时就凸显出了ip地址的好处：如果在不同局域网中的机器要通信，首先要判断目标机器的ip地址所处的网段。



那么路由器如何知道哪个网段呢？

路由器内部会存储一个路由表，表里面都是由网段以及对应网段的网关组成的一条条记录。之后发送到路由器的消息会判断发送到哪个网段，然后转发给网段对应的网关。



**过路由器是为了找圈，过交换机是为了找圈里的机器**

![image-20200613112732237](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200613112732237.png)



每一个局域网内部都有一个网段和交换机

局域网与局域网进行通信：网关(不同局域网的代理对象)，路由器(帮助找到网段之后再发消息给对应的网关来找到目标机器)



**路由器可以理解ip地址，普通的交换机不可以理解ip地址，只能理解mac地址**





### ip地址

一台机器的临时地址，



#### Ipv4：

有一个ipv4协议，规定ip地址由一个4位的点分十进制组成。例如192.168.12.128，实际上每一个点分开的都是8位二进制。



#### 公网地址

直接给我们的ip地址是没有办法被别人访问到的，只有**公网ip(需要购买)**才可以

![image-20200613114552263](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200613114552263.png)



#### 内网地址（内网中通信用交换机，公网中用路由器）

有些地址我们保留下来了，例如，越往下表示的范围越大

- 192.168.0.0 - 192.168.255.255 
- 172.16.0.0 - 172.31.255.255
- 10.0.0.0 - 10.255.255.255

特殊的ip地址：127.0.0.1 **本地回环地址** 。如果访问，只需要过网卡即可不需要过交换机。(测试时候用)



win: 查看ip地址，ipconfig

Mac/linux: ifconfig



![image-20200613120552807](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200613120552807.png)



首先我们分配ip地址，192.168.xx.0是一个网段，然后192.168.xx.1是网关，对应网段内只能有254台机器，因此如果有一个500多人的团队，需要分配ip地址，那么如何处理：使用192.168.0.0作为网段，但是此时交换机无法区分192.168.12.x与192.168.13.x到底是不是一个网络上的。因此便会出现一个新的概念：子网掩码(大多都是由255和0组成)



子网掩码：也是一个ip地址，用来判断两台机器在不在一个局域网中，如何判断：总是用一台机器的ip地址和子网掩码进行按位与。与完之后相等就在一个局域网中，否则就不在一个局域网中。



因此判断两个ip地址是否在一个局域网中不能光看ip地址**还得结合子网掩码**



![image-20200613120317475](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200613120317475.png)

#### ipv6

6位冒分十六进制

0:0:0:0:0:0 - FFFFFF:FFFFFF:FFFFFF:FFFFFF:FFFFFF:FFFFFF:192.168.12.3



前面96位 + 后面32位本机的Ipv4地址







# 163 CS和BS架构



## 端口

**ip以及mac是用来确认机器的，而端口是用来确认机器上的应用程序的**

范围：0-65535 

端口用来区分本机上的应用程序

端口不固定，可以修改，访问网页默认都是80





概念整理：![image-20200613122142503](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200613122142503.png)





![image-20200613162830816](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200613162830816.png)

# 164 socket编码(tcp协议中的通信)

使用socket模块来操作套接字，以下模拟的都是tcp协议中的通信

server代码如下：

```python
"""
@File : server.py

@Author: sivan Wu

@Date : 2020/6/13 8:22 下午

@Desc :

"""

import socket

# 1. 实例化一个socket模块中socket类的对象
sk = socket.socket()
# 2. 服务端绑一个地址(本机地址或自己的ip地址)以及端口，因为别人要找你
# 传入的参数是一个元祖，第一个是字符串类型，代表ip地址，第二个是整形，代表端口
sk.bind(("127.0.0.1", 9001))
# 3. 开启监听，等待别人连接
sk.listen()
# 4. 接收客户端的连接，连上之后会返回一个连接以及地址(包括对面的ip地址以及端口)
conn, address = sk.accept()
print(address)
# 5. 我们和他说话使用send(),传入的只能是字节类型的数据，
conn.send(b"hello")
# 6. 他和咱们说话使用recv
msg = conn.recv(1024)  # 接收1024个字节的数据，如果超过也只接受1024个
print(msg)
# 7. 结束对话
conn.close()
# 8. 关掉服务
sk.close()

```

client代码如下：

```python
"""
@File : client.py

@Author: sivan Wu

@Date : 2020/6/13 8:22 下午

@Desc :

"""

import socket
# 1. 创建一个套接字对象
sk = socket.socket()
# 2. 连接服务端, 必须是服务端的ip地址以及端口
sk.connect(("127.0.0.1", 9001))
# 3. 接收server端传来的数据，因为server端中首先发送数据
data = sk.recv(1024)
print(data)
# 4. 发送数据给服务端，因为server端中发送数据之后会接收数据
sk.send(b"i am client")
# 5. 关闭
sk.close()

```



# 165 tcp,udp和osi

## 7层协议

顺口溜：应表会传网数物

1. 应用层
2. 表示层
3. 会话层
4. 传输层
5. 网络层
6. 数据链路层
7. 物理层

## 5层协议（目前应用最多）

1. 应用层(合并了7层协议的表示层以及会话层)
2. 传输层：和**端口**有关的所有内容都在传输层。端口相关的在传输层。(协议：tcp和udp协议)(硬件设备：四层交换机，四层路由器，可以解析到端口，直接将数据发送到端口对应的应用程序中)
3. 网络层：将数据包拼接**ip**地址。ip地址相关的在网络层。(协议：ipv4，ipv6协议）。（硬件设备：路由器，三层交换机(具有路由功能，可以发挥路由器的功能)）
4. 数据链路层：将数据包拼接**mac地址**。mac地址相关的在数据链路层。(协议：arp协议)(硬件设备：二层交换机， 网卡)
5. 物理层：将数据包转换成电信号通过网线传输。



五层协议中第一层是物理层，就像我们数楼层一样。(从下往上数)

我们家里的路由器除了现在的路由功能，现在也带了交换机的功能，就实现了局域网间以及局域网内的通信

网线上只可以传递高低电压，不可以传递字节。

套接字如何理解呢？因为网络是一层一层的传输不断地加上新的内容打包装可以理解为套接字不断套东西。

我们写的python的代码就是应用层，我们写的socket代码会帮我们管理应用层以下的层，不需要我们不断的套东西，socket替我们做了。

## tcp和udp

tcp以及udp都属于传输层上的协议。





例如微信上给人发消息，我们不着急，等消息发送出去即可，但是打电话我们直接打过去必须得接，会占连接。

Tcp： 打电话，适合于语音聊天，视频聊天。线下缓存的高清电影都是tcp。远程控制。发邮件。

- tcp协议是一个需要先建立连接然后才可以通信的协议。
- 占用连接，可靠(依赖回执，消息不会丢失)，实时性高，慢(需要等别人的回执)
- 实时性高
- **建立连接：三次握手![image-20200613220230270](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200613220230270.png)**

Udp：发短信，适合于发消息。所有视频在线播放软件都是udp。QQ发消息。微信发消息。

- udp协议是一个不需要建立连接就可以通信的协议。
- 不占用连接，不可靠，速度快，



总之在乎时间的，一对多的大多都是udp协议，比较不在乎时间的但是要数据准确时我们可以采用tcp。



**建立连接(三次握手)：![image-20200613220230270](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200613220230270.png)**

1. 首先想要建立连接的一方A发送一个请求连接服务到目标对象B
2. 之后B回复一个确认ACK，同时由于tcp是双向的，此时B也会发起一个建立连接的请求SYN到A，此时只建立了A到B的单向通信
3. A收到了来自B的建立连接请求，因而返回一个ACk，至此双向连接建立。



因为tcp是双向连接的，这种双向通信叫做全双工通信(两边都可以通信)。



一条send对应一条recv,我们发送指定内容时，协议会帮助我们自动回复确认







**断开连接(两边都可以发起断开连接的请求，四次挥手)：**

1. 断开连接的一方A向另一方B发送断开连接的请求 FIN
2. B向A回复一个ACK，此时A到B的连接关闭，但是B依然可以发送消息到A
3. 当B的数据传输到A后，此时B发起断开连接的请求FIN
4. A回复一个ACK，关闭了B到A的连接，此时双向连接全部关闭



**问题来了：为什么握手的时候是三次，挥手的时候是四次？**

因为我发起断开连接的请求表示我话说完，没话可以说了，但是你可能还有一些遗留的数据还要发送，发完之后你才主动发起断开连接的请求。所以挥手的时候是四次，因为不能保证你断开连接的时候，我所有的数据也已发送完毕。



重点：

![image-20200613221628508](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200613221628508.png)



上边编写的代码理解：

![image-20200613222110077](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200613222110077.png)

# 166 包的导入

参考博客：https://www.cnblogs.com/Eva-J/articles/7292109.html#_label12![image-20200614090011883](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200614090011883.png)



![image-20200614091055863](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200614091055863.png)

![image-20200614085855229](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200614085855229.png)



demo.py代码如下：

```python
"""
@File : demo.py

@Author: sivan Wu

@Date : 2020/6/14 8:09 上午

@Desc :

"""
import glance  # 可以导入，原因：因为glance与我们这个文件在同一级目录下
print(glance)
# 能不能到某一个包进来就看sys.path就行，如果glance的父目录在sys.path里面就可以导入
import sys
print(sys.path)
# 报错：AttributeError: module 'glance' has no attribute 'api'
# 原因：导入一个包import glance只是相当于执行了这个包下的__init__.py文件，并不是把这个包下的所有文件都导入进来了
# glance.api.policy.get()

# 要想直接导入某个包(文件夹)下的文件
# 方式一： import
import glance.api.policy as policy
policy.get()

# 方式二：from . import .  不可以写成from glance import api.policy ，因为import后面必须是一个明确的文件或方法，
# from import中import后面不能带点，并且from 到 import之间的语句中.号前面必须是一个包
from glance.api import policy  # 直接从一个包中导入文件
from glance.api.policy import get  # 直接从包的文件中导入函数名/变量名
# from glance import api.policy  # 报错
policy.get()


# 进阶：我们就想导入glance之后可以使用glance下的所有文件
# 注意: sys.path中的第一个元素一定是当前执行文件的父目录
import sys
print(sys.path)
# 绝对导入
import glance


# 相对导入 . 表示当前目录，..表示上一级目录
# 因为当我们挪动目录的时候会报错，所以可以使用相对导入，
# 相对导入特点：只要能找到包，就能找到包里的所有文件。
# 相对导入缺点：当我们一个py文件中有相对导入的时候，如果执行该文件就会报错。因为相对导入的文件不可以直接执行

```



![image-20200614091457107](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200614091457107.png)



实际工作中如何处理包呢？

![image-20200614091132317](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200614091132317.png)



# 167 选课系统作业讲解



步骤：

1. 管理员登录，管理员要给一个账户和密码(我们都自己创建好保存到管理员文件中，登录即可)
2. 创建学生以及课程(让用户输入学生以及课程信息，然后实例化保存到文件(学生以及课程都有各自的文件)里面)
3. 学生可以选多门课，那么如何存储？
4. 学生只要选课就涉及到文件的修改，不要怕麻烦



只要用上反射就很简单，不会有大量的判断

![image-20200614093035186](/Users/yirufeng/%E5%AE%9E%E4%B9%A0/%E9%A1%B9%E7%9B%AE/images/img/image-20200614093035186.png)